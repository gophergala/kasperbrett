package main

import (
	"errors"
	"fmt"
	"gopkg.in/tomb.v2"
	"time"
)

func main() {
	fmt.Println("Hello Kasperbrett!")
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ██████╗ ███████╗██████╗  ██████╗ ██████╗ ████████╗██╗███╗   ██╗ ██████╗  ***** */
/* ***** ██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗╚══██╔══╝██║████╗  ██║██╔════╝  ***** */
/* ***** ██████╔╝█████╗  ██████╔╝██║   ██║██████╔╝   ██║   ██║██╔██╗ ██║██║  ███╗ ***** */
/* ***** ██╔══██╗██╔══╝  ██╔═══╝ ██║   ██║██╔══██╗   ██║   ██║██║╚██╗██║██║   ██║ ***** */
/* ***** ██║  ██║███████╗██║     ╚██████╔╝██║  ██║   ██║   ██║██║ ╚████║╚██████╔╝ ***** */
/* ***** ╚═╝  ╚═╝╚══════╝╚═╝      ╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝  ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type Reporter interface {
	OnSample(sample *Sample)
	Prepare() error
	ShutDown() error
}

type ReportingEngine interface {
	Register(reporters ...Reporter)
	Distribute(sample *Sample)
	ShutDown() error
}

type Sample struct {
	Value        string
	Timestamp    time.Time
	DataSourceId string
	Err          error
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

/* ***** ███████╗ ██████╗██╗  ██╗███████╗██████╗ ██╗   ██╗██╗     ██╗███╗   ██╗ ██████╗  ***** */
/* ***** ██╔════╝██╔════╝██║  ██║██╔════╝██╔══██╗██║   ██║██║     ██║████╗  ██║██╔════╝  ***** */
/* ***** ███████╗██║     ███████║█████╗  ██║  ██║██║   ██║██║     ██║██╔██╗ ██║██║  ███╗ ***** */
/* ***** ╚════██║██║     ██╔══██║██╔══╝  ██║  ██║██║   ██║██║     ██║██║╚██╗██║██║   ██║ ***** */
/* ***** ███████║╚██████╗██║  ██║███████╗██████╔╝╚██████╔╝███████╗██║██║ ╚████║╚██████╔╝ ***** */
/* ***** ╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═════╝  ╚═════╝ ╚══════╝╚═╝╚═╝  ╚═══╝ ╚═════╝  ***** */
/* ***** Banner comment generated by http://patorjk.com/software/taag ***** ***** ****** ***** */

// TODO: Refactor this section to a separate package!
// TODO: Add test cases

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type SchedulerJob struct {
	ticker *time.Ticker
	t      tomb.Tomb
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type Scheduler interface {
	Schedule(dataSourceId string, interval time.Duration, jobFn func(reportingEngine ReportingEngine)) (chan string, chan error)
	GetAll() (chan map[string]*SchedulerJob, chan error)
	Cancel(dataSourceId string) (chan bool, chan error)
	ShutDown() (chan bool, chan error)
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type SchedulerRequest interface {
	Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine)
	ErrorChan() chan error
	IsShutDownRoutine() bool
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewAbstractSchedulerRequest() AbstractSchedulerRequest {
	return AbstractSchedulerRequest{errorChan: make(chan error, 1)}
}

type AbstractSchedulerRequest struct {
	errorChan chan error
}

func (req AbstractSchedulerRequest) ErrorChan() chan error {
	return req.errorChan
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type AddJobRequest struct {
	AbstractSchedulerRequest
	responseChan chan string
	interval     time.Duration
	jobFn        func(reportingEngine ReportingEngine)
	dataSourceId string
}

func (req AddJobRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	job := &SchedulerJob{ticker: time.NewTicker(req.interval)}
	registry[req.dataSourceId] = job

	job.t.Go(func() error {
		for {
			select {
			case <-job.ticker.C:
				req.jobFn(reportingEngine)
			case <-job.t.Dying():
				return nil
			}
		}
	})

	req.responseChan <- req.dataSourceId
}

func (req AddJobRequest) IsShutDownRoutine() bool {
	return false
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type GetAllJobsRequest struct {
	AbstractSchedulerRequest
	responseChan chan map[string]*SchedulerJob
}

func (req GetAllJobsRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	registrySnapshot := make(map[string]*SchedulerJob, len(registry))

	for jobId, job := range registry {
		jobCopy := *job
		registrySnapshot[jobId] = &jobCopy
	}

	req.responseChan <- registrySnapshot
}

func (req GetAllJobsRequest) IsShutDownRoutine() bool {
	return false
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type RemoveJobRequest struct {
	AbstractSchedulerRequest
	responseChan chan bool
	jobId        string
}

func (req RemoveJobRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	job, ok := registry[req.jobId]
	var err error = nil
	if !ok {
		err = errors.New("Job not available: " + req.jobId)
	} else {
		job.ticker.Stop()
		delete(registry, req.jobId)
		job.t.Kill(nil)
		err = job.t.Wait()
	}
	req.errorChan <- err
	req.responseChan <- true
}

func (req RemoveJobRequest) IsShutDownRoutine() bool {
	return false
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

type RemoveAllJobsRequest struct {
	AbstractSchedulerRequest
	responseChan chan bool
}

func (req RemoveAllJobsRequest) Run(registry map[string]*SchedulerJob, reportingEngine ReportingEngine) {
	var overallErr error = nil
	for jobId, job := range registry {
		// TODO: remove redundant code
		job.ticker.Stop()
		delete(registry, jobId)
		job.t.Kill(nil)
		err := job.t.Wait()

		if err != nil && overallErr == nil {
			overallErr = err
		}
	}
	req.errorChan <- overallErr
	req.responseChan <- true
}

func (req RemoveAllJobsRequest) IsShutDownRoutine() bool {
	return true
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */

func NewKasperbrettScheduler(reportingEngine ReportingEngine) *KasperbrettScheduler {
	ks := &KasperbrettScheduler{
		reportingEngine: reportingEngine,
		requestChan:     make(chan SchedulerRequest),
		registry:        make(map[string]*SchedulerJob),
		isShutDown:      false,
	}

	go func() {
		for {
			req := <-ks.requestChan

			if ks.isShutDown {
				errorChan := req.ErrorChan()
				errorChan <- errors.New("The KasperbrettScheduler has already been shut down.")
			} else {
				req.Run(ks.registry, ks.reportingEngine)
				ks.isShutDown = req.IsShutDownRoutine()
			}
		}
	}()

	return ks
}

type KasperbrettScheduler struct {
	reportingEngine ReportingEngine
	requestChan     chan SchedulerRequest
	registry        map[string]*SchedulerJob
	isShutDown      bool
}

func (ks *KasperbrettScheduler) Schedule(dataSourceId string, interval time.Duration, jobFn func(reportingEngine ReportingEngine)) (chan string, chan error) {
	// we need a buffered chan in case the caller is not interested in the response value (jobId)
	// an unbuffered chan would block our request processing goroutine forever
	responseChan := make(chan string, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := AddJobRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
		interval:                 interval,
		jobFn:                    jobFn,
		dataSourceId:             dataSourceId,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

func (ks *KasperbrettScheduler) GetAll() (chan map[string]*SchedulerJob, chan error) {
	// reasoning for buffered chan: see explanation in Schedule() impl.
	responseChan := make(chan map[string]*SchedulerJob, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := GetAllJobsRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

func (ks *KasperbrettScheduler) Cancel(jobId string) (chan bool, chan error) {
	// reasoning for buffered chan: see explanation in Schedule() impl.
	responseChan := make(chan bool, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := RemoveJobRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
		jobId:                    jobId,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

func (ks *KasperbrettScheduler) ShutDown() (chan bool, chan error) {
	// reasoning for buffered chan: see explanation in Schedule() impl.
	responseChan := make(chan bool, 1)
	abstractSchedulerRequest := NewAbstractSchedulerRequest()

	req := RemoveAllJobsRequest{
		AbstractSchedulerRequest: abstractSchedulerRequest,
		responseChan:             responseChan,
	}
	ks.requestChan <- req

	return responseChan, abstractSchedulerRequest.ErrorChan()
}

/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
/* ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** */
